// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.commands.*;
import edu.wpi.first.wpilibj.I2C.Port;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
    import com.kauailabs.navx.frc.AHRS;
/**
 *
 */
public class Drivetrain extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private WPI_TalonSRX leftFrontMotor;
private WPI_TalonSRX leftBackMotor;
private WPI_TalonSRX rightFrontMotor;
private WPI_TalonSRX rightBackMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private AHRS m_gyro;

    private static final double TICKS_PER_FOOT = 5270;
    private static final double THRESHOLD = 500;
    private static final int TIMEOUT_MS = 10;

    private static final double MM_P = 0.8;
    private static final double MM_I = 0;
    private static final double MM_D = 0.001;
    private static final double MM_F = 0.65;
    private static final double MM_VELOCITY = 0;
    private static final double MM_ACCELERATION = 0;
    private static final int MM_PIDINDEX = 0;
    private static final int MM_PIDSLOT = 0;
    private double MM_DISTANCE;
    /**
    *
    */
    public Drivetrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftFrontMotor = new WPI_TalonSRX(2);
 
 

leftBackMotor = new WPI_TalonSRX(3);
 
 

rightFrontMotor = new WPI_TalonSRX(7);
 
 

rightBackMotor = new WPI_TalonSRX(9);
 
 


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        brake();
        // coast();

        rightFrontMotor.setInverted(true);

        rightBackMotor.setInverted(true);

        leftBackMotor.follow(leftFrontMotor);

        rightBackMotor.follow(rightFrontMotor);

        m_gyro = new AHRS(Port.kMXP);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void run(double l, double r) {
        leftFrontMotor.set(l);
        rightFrontMotor.set(r);
        // test, test, test
    }

    public void stop() {
        run(0, 0);
    }

    public void brake() {
        leftFrontMotor.setNeutralMode(NeutralMode.Brake);
        leftBackMotor.setNeutralMode(NeutralMode.Brake);
        rightFrontMotor.setNeutralMode(NeutralMode.Brake);
        rightBackMotor.setNeutralMode(NeutralMode.Brake);
    }

    public void coast() {
        leftFrontMotor.setNeutralMode(NeutralMode.Coast);
        leftBackMotor.setNeutralMode(NeutralMode.Coast);
        rightFrontMotor.setNeutralMode(NeutralMode.Coast);
        rightBackMotor.setNeutralMode(NeutralMode.Coast);
    }

    public void initMotionMagic(double velocity, double acceleration, double distance) {
        MM_DISTANCE = distance*TICKS_PER_FOOT;
        leftFrontMotor.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, MM_PIDINDEX, TIMEOUT_MS);
        rightFrontMotor.configSelectedFeedbackSensor(FeedbackDevice.QuadEncoder, MM_PIDINDEX, TIMEOUT_MS);

        leftFrontMotor.configNominalOutputForward(0, TIMEOUT_MS);
        leftFrontMotor.configNominalOutputReverse(0, TIMEOUT_MS);
        leftFrontMotor.configPeakOutputForward(1, TIMEOUT_MS);
        leftFrontMotor.configPeakOutputReverse(-1, TIMEOUT_MS);

        rightFrontMotor.configNominalOutputForward(0, TIMEOUT_MS);
        rightFrontMotor.configNominalOutputReverse(0, TIMEOUT_MS);
        rightFrontMotor.configPeakOutputForward(1, TIMEOUT_MS);
        rightFrontMotor.configPeakOutputReverse(-1, TIMEOUT_MS);

        leftFrontMotor.selectProfileSlot(MM_PIDSLOT, MM_PIDINDEX);
        rightFrontMotor.selectProfileSlot(MM_PIDSLOT, MM_PIDINDEX);

        leftFrontMotor.config_kP(0, MM_P, TIMEOUT_MS);
        leftFrontMotor.config_kI(0, MM_I, TIMEOUT_MS);
        leftFrontMotor.config_kD(0, MM_D, TIMEOUT_MS);
        leftFrontMotor.config_kF(0, MM_F, TIMEOUT_MS);

        rightFrontMotor.config_kP(0, MM_P, TIMEOUT_MS);
        rightFrontMotor.config_kI(0, MM_I, TIMEOUT_MS);
        rightFrontMotor.config_kD(0, MM_D, TIMEOUT_MS);
        rightFrontMotor.config_kF(0, MM_F, TIMEOUT_MS);

        leftFrontMotor.configMotionAcceleration(acceleration, TIMEOUT_MS);
        leftFrontMotor.configMotionCruiseVelocity(velocity, TIMEOUT_MS);

        rightFrontMotor.configMotionAcceleration(acceleration, TIMEOUT_MS);
        rightFrontMotor.configMotionCruiseVelocity(velocity, TIMEOUT_MS);

        leftFrontMotor.setSelectedSensorPosition(0, MM_PIDINDEX, TIMEOUT_MS);
        rightFrontMotor.setSelectedSensorPosition(0, MM_PIDINDEX, TIMEOUT_MS);

        leftFrontMotor.set(ControlMode.MotionMagic, MM_DISTANCE);
        rightFrontMotor.set(ControlMode.MotionMagic, MM_DISTANCE);
    }

    public boolean isAtPIDDestination() {
        return (Math.abs(leftFrontMotor.getSelectedSensorPosition() - MM_DISTANCE) < THRESHOLD) || (Math.abs(rightFrontMotor.getSelectedSensorPosition() - MM_DISTANCE) < THRESHOLD);
    
    }
    // *** add the extra stuff
    //public boolean isAtPIDDestination 
}
